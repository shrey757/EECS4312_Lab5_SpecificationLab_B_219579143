## Student Name:
## Student ID: 

Prompt 1: "here is my code i need help to check my indentation and logic: ## Student Name: Shrey Grover ## Student ID: 219579143 """ Stub file for the is allocation feasible exercise. Implement the function is_allocation_feasible to Determine whether a set of resource requests can be satisfied given limited capacities. Take int account any possible constraints. See the lab handout for full requirements. """ from typing import Dict, List, Union import math Number = Union[int, float] def is_allocation_feasible( resources: Dict[str, Number], requests: List[Dict[str, Number]] ) -> bool: """ Determine whether a set of resource requests can be satisfied given limited capacities. Args: resources : Dict[str, Number], Mapping from resource name to total available capacity. requests : List[Dict[str, Number]], List of requests. Each request is a mapping from resource name to the amount required. Returns: True if the allocation is feasible, False otherwise. """ # TODO: Implement this function if not isinstance(resources, dict): raise ValueError("resources must be a dict") if not isinstance(requests, list): raise ValueError("requests must be a list of dicts") # Validate capacities + prepare totals totals: Dict[str, float] = {} for name, cap in resources.items(): if not isinstance(name, str): raise ValueError("resource names must be strings") if not isinstance(cap, (int, float)) or isinstance(cap, bool): raise ValueError("resource capacities must be numeric") cap_f = float(cap) if math.isnan(cap_f) or cap_f < 0: raise ValueError("resource capacities must be non-negative and not NaN") totals[name] = 0.0 # Accumulate demands for req in requests: if not isinstance(req, dict): raise ValueError("each request must be a dict") for rname, amt in req.items(): # Unknown resource => infeasible if rname not in resources: return False if not isinstance(amt, (int, float)) or isinstance(amt, bool): raise ValueError("requested amounts must be numeric") amt_f = float(amt) if math.isnan(amt_f) or amt_f < 0: raise ValueError("requested amounts must be non-negative and not NaN") totals[rname] += amt_f # Check feasibility for rname, total in totals.items(): if total > float(resources[rname]): return False return True"

LLM Response 1: "here is my code i need help to check my indentation and logic: ## Student Name: Shrey Grover
## Student ID: 219579143

"""
Stub file for the is allocation feasible exercise.

Implement the function `is_allocation_feasible` to  Determine whether a set of resource requests can be satisfied 
given limited capacities. Take int account any possible constraints. See the lab handout
for full requirements.
"""
    
from typing import Dict, List, Union
import math

Number = Union[int, float]


def is_allocation_feasible(
    resources: Dict[str, Number],
    requests: List[Dict[str, Number]]
) -> bool:
    """
    Determine whether a set of resource requests can be satisfied given limited capacities.

    Args:
        resources : Dict[str, Number], Mapping from resource name to total available capacity.
        requests : List[Dict[str, Number]], List of requests. Each request is a mapping from resource name to the amount required.

    Returns:
        True if the allocation is feasible, False otherwise.

    """
    # TODO: Implement this function
    if not isinstance(resources, dict):
        raise ValueError("resources must be a dict")
    if not isinstance(requests, list):
        raise ValueError("requests must be a list of dicts")

    # Validate capacities + prepare totals
    totals: Dict[str, float] = {}
    for name, cap in resources.items():
        if not isinstance(name, str):
            raise ValueError("resource names must be strings")
        if not isinstance(cap, (int, float)) or isinstance(cap, bool):
            raise ValueError("resource capacities must be numeric")
        cap_f = float(cap)
        if math.isnan(cap_f) or cap_f < 0:
            raise ValueError("resource capacities must be non-negative and not NaN")
        totals[name] = 0.0

    # Accumulate demands
    for req in requests:
        if not isinstance(req, dict):
            raise ValueError("each request must be a dict")

        for rname, amt in req.items():
            # Unknown resource => infeasible
            if rname not in resources:
                return False

            if not isinstance(amt, (int, float)) or isinstance(amt, bool):
                raise ValueError("requested amounts must be numeric")
            amt_f = float(amt)
            if math.isnan(amt_f) or amt_f < 0:
                raise ValueError("requested amounts must be non-negative and not NaN")

            totals[rname] += amt_f

    # Check feasibility
    for rname, total in totals.items():
        if total > float(resources[rname]):
            return False

    return True"

--------------------------------------------------
Prompt 2: "can you help me with some assumptions about my code"
LLM Response 2: "Yes. Here are **reasonable “assumptions” you can state** for *your* current implementation (and I’ll flag what changes if the lab expects something else).

## Assumptions your code currently makes

1. **Shared-pool model (aggregate feasibility)**

* All requests are combined.
* Allocation is feasible **iff** for every resource:
  total requested ≤ total capacity.

2. **Requests are “splittable” / not tied to timing**

* You’re not allocating in an order or “per time slot.”
* You assume resources don’t need to be reserved at different times—just total demand.

3. **No per-request constraints**

* You are *not* enforcing rules like “a single request can’t exceed X% of a resource” or “each request must be fully satisfied individually at allocation time.”
* Only totals matter.

4. **All requested resource names must exist in `resources`**

* If a request mentions an unknown resource, you assume it’s infeasible (return `False`).

5. **Missing resources in a request mean 0**

* If a request doesn’t include `"ram"` (for example), you assume it requests 0 RAM.

6. **Non-negative numeric inputs only**

* Capacities must be numbers (not bool), **≥ 0**, not NaN.
* Request amounts must be numbers (not bool), **≥ 0**, not NaN.

7. **Fractional allocations are allowed**

* Because you accept floats, you assume it’s okay to request/allocate e.g. `2.5` units of CPU.
* If the lab expects integer-only resources, you’d need to enforce ints.

---

## If your lab’s “constraints” mean something else, tell me which one applies

Here are the common variants, and how your assumptions would change:

* **Online / sequential allocation:** must never exceed capacity at any step (still totals, but order can matter if there are releases—your code doesn’t model releases at all).
* **Per-request must fit:** each request’s amount must be ≤ capacity individually (easy extra check).
* **Integer-only resources:** reject floats or require whole numbers.
* **Dependencies:** e.g., “if GPU requested, must also request CPU ≥ 1” (custom rules).

If you paste the lab’s constraint bullets (1 screenshot or text), I’ll rewrite your “Assumptions” section to match it exactly and tell you the minimal code tweaks if needed.
"
--------------------------------------------------
